# Cryptographic Scenarios

By Kendra Winhall

## Simple communication scenarios

1. Alice wants to send Bob a long message, and she doesn't want Eve to be able to read it. Assume for this scenario that AITM is impossible.
    * Description:
        * Alice and Bob use Diffie-Hellman to agree upon a key `K`. 
        * Define `M` as Alice's plaintext message. 
        * Alice computes `C = AES(K, M)` and sends `C` to Bob. 
        * Bob computes `M = AES(K, C)` to read the message.
    * Explanation:
        * Because Alice is using symmetric encryption, it is quick to encrypt and decrypt her long message. 
        * Eve cannot read the message unless she knows `K`. However, Eve cannot know `K` because Alice and Bob used Diffie-Hellman to agree upon the value of `K`. (Assuming that AITM is impossible, Diffie-Hellman ensures that two parties can generate `K` over a public, insecure network without Eve being able to determine `K`'s value.) Therefore, Alice's message to Bob is confidential.

2. Alice wants to send Bob a long message. She doesn't want Mal to be able to modify the message without Bob detecting the change.
    * Description:
        * Define `M` as Alice's plaintext message.
        * Alice uses SHA-256 to compute `D = H(M)`. 
        * Alice sends `M||D` to Bob
        * Bob computes `D' = H(M)`.
        * If `D = D'`, then Bob knows the message has not been modified. If `D != D'`, then Bob knows that the message has been modified.
    * Explanation:
        * Because cryptographic hash functions are deterministic, pre-image resistant, and collision resistant, the only scenario where `D = D'` is where the message that was hashed to create `D` is the exact same message that was hashed to create `D'`. 
        * Therefore, if Alice sends `M||D` to Bob, Bob knows the original value of `H(M) = D`. When Bob recomputes `H(M) = D'`, he can verify that the message has not been changed by checking that `D = D'`. If `D != D'`, then `M` has changed in transit.

3. Alice wants to send Bob a long message (in this case, it's a signed contract between AliceCom and BobCom), she doesn't want Eve to be able to read it, and she wants Bob to have confidence that it was Alice who sent the message. Assume for this scenario that AITM is impossible.
    * Description:
        * Alice and Bob use Diffie-Hellman to agree upon a key `K`. Define `M` as Alice's plaintext message.
        * Alice computes `D = H(M)` and `Sig = E(S_A, D)`.
        * Alice sends `AES(K, M||Sig)` to Bob.
        * Bob computes `AES(K, AES(K, M||Sig))` to get `M||Sig`. Then, Bob computes `D’ = H(M)`.
        * If `E(P_A, Sig) = D’`, then Bob knows that Alice sent the message. (Bob also knows that the message has not been modified.) 
    * Explanation:
        * Although `D` is encrypted using asymmetric encryption--which is slower than symmetric encryption--it is quick to compute `Sig` because `D` is a short message (solely consisting of a hash function digest). Then, because Alice is using symmetric encryption to encrypt `M||Sig`, it is quick to encrypt and decrypt her long message. 
        * As explained more thoroughly in the first question, Eve must know `K` in order to read the message, and Eve cannot know `K` because Alice and Bob used Diffie-Hellman to agree upon the value of `K`. Therefore, Alice's message to Bob is confidential.
        * Bob can verify that Alice sent the message by encrypting Alice's signature with her public key and checking that the result is equal to the digest he computes. Say that Bob computes `D’ = H(M)`. Evidently, the only scenario where `E(P_A, Sig) = E(P_A, E(S_A, D)) = D'` is when `Sig` is generated by encrypting `D` using Alice's secret key `S_A`. Therefore, if `E(P_A, Sig) = D`, then the only key that could have been used to encrypt the `D` and generate `Sig`is `S_A`--which only Alice knows. Assuming that `P_A` truly belongs to Alice and `S_A` is truly secret, then if Bob confirms that `E(P_A, Sig) = D’`, he can be confident that Alice sent the message.

## Questions about breaking security

4. Consider a scenario where Alice and Bob have been in contract negotiations and sharing documents electronically along the way. Suppose Bob sues Alice for breach of contract and presents as evidence the digitally signed contract `(C || Sig)` and Alice's public key `P_A`. Here, `C` contains some indication that Alice has agreed to the contract—e.g., if `C` is a PDF file containing an image of Alice's handwritten signature. `Sig`, on the other hand is a digital signature. Suppose Alice says in court "`C` is not the contract I sent to Bob". (This is known as repudiation in cryptographic vocabulary.) Alice will now need to explain to the court what she believes happened that enabled Bob to end up with an erroneous contract. List at least three things Alice could claim happened. For each of Alice's claims, state briefly how plausible you would find the claim if you were the judge. (Assume that you, the judge, studied cryptography in college.)
    1. Alice could claim that she sent the message, but it was altered in transit by a malicious attacker. This situation is plausible, and it would be easy to check if this is true. Specifically, since `Sig = E(S_A, D)`, where `D = H(C)`, the judge could compute `D' = H(C)` check whether `E(P_A, Sig) = E(P_A, E(S_A, D)) = D'`. If so, then this shows that `C` had not been changed in transit (since the digest is the same), and Alice is lying. If not, then Alice may be telling the truth.
    2. Alice could claim that somebody else sent the message and forged Alice's signature. This is not very plausible, but also easy to check. If `E(P_A, Sig) = E(P_A, E(S_A, D)) = D'`, then this confirms that `Sig` was generated by encrypting `D` using Alice's secret key `S_A`--meaning that Alice signed the document, so she is lying. If not, then it is possible that a different secret key was used, and Alice may be telling the truth.
    3. Alice could claim that `S_A` was compromised. This is plausible, but signals that Alice is not being responsible with her secret key. Presumably, Alice would need some evidence of the security incident that compromised her secret key, as well as evidence showing that a malicious attacker used the key. This would raise the question of why Alice didn't revoke her certificate once she discovered this incident.

5. For this scenario, suppose the assumption that everybody has everybody else's correct public keys is no longer true. Instead, suppose we now have a certificate authority CA, and that everybody has the correct `P_CA` (i.e. the certificate authority's key). Suppose further that Bob sent his public key `P_B` to CA, and that CA then delivered to Bob this certificate: `Cert_B = "bob.com" || P_B || Sig_CA`. In terms of `P_CA`, `S_CA`, `H`, `E`, etc., of what would `Sig_CA` consist? That is, show the formula CA would use to compute `Sig_CA`.
    * To compute `Sig_CA`, the CA would use the formula `Sig_CA = E(S_CA, H("bob.com"||P_B))`. That is, the CA concatenates the domain "bob.com" with Bob's public key `P_B` (verifying that the public key belongs to Bob) and hashes that data. Then, the CA encrypts this hashed data with their secret key `S_CA`. Then, anyone can check if the certificate is legitimate by computing `E(P_CA, Sig_CA)` and checking if it's equal to the hashed data.

6. Bob now has the certificate `Cert_B` from the previous question. During a communication, Bob sends Alice `Cert_B`. Is that enough for Alice to believe she's talking to Bob? (Hint: no.) What could Alice and Bob do to convince Alice that Bob has the `S_B` that goes with the `P_B` in `Cert_B`?
    * In order for Alice to be convinced that she's talking to Bob, she needs to validate the certificate. She can do this by computing `X = H("bob.com" || P_B)` and `Y = E(P_CA, Sig_CA)`. If the certificate is legitimate, then `Y = E(P_CA, Sig_CA) = E(P_CA, E(S_CA, H("bob.com"||P_B))) = H("bob.com"||P_B) = X`. If `Y = X`, then the certificate is legitimate and Alice can be confident that she's talking to Bob. If `Y != X`, then the certificate is not legitimate, and Alice cannot verify that she's talking to Bob.

7. Finally, list at least two ways the certificate-based trust system from the previous two questions could be subverted, allowing Mal to convince Alice that Mal is Bob.
    1. First, it's possible for Mal to create a key `P_B` and trick a CA by pretending to be Bob. Then the CA issues a certificate stating that Bob owns `P_B`, but it actually belongs to Mal. Then Mal can communicate with Alice, pretending to be Bob, and can present the certificate to trick Alice.
    2. Second, it's possible for Mal to compromise the CA itself. If Mal has a key `P_B` and compromises the CA, they can issue a certificate stating that Bob owns `P_B` (even though that's Mal's key). Then Mal can communicate with Alice, pretending to be Bob, and can present the certificate to trick Alice.
